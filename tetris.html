<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris - React Version</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-gray-900">
    <div id="root"></div>
    <script type="text/babel" data-presets="react,typescript">
        const { useState, useEffect, useCallback, useRef } = React;

        // --- useTetris.ts ---
        const useTetris = () => {
            const [board, setBoard] = useState(createEmptyBoard());
            const [player, setPlayer] = useState(null);
            const [score, setScore] = useState(0);
            const [lines, setLines] = useState(0);
            const [level, setLevel] = useState(1);
            const [isRunning, setIsRunning] = useState(false);
            const [isGameOver, setIsGameOver] = useState(false);
            const [nextQueue, setNextQueue] = useState([]);
            const [holdPiece, setHoldPiece] = useState(null);
            const [canHold, setCanHold] = useState(true);

            const [settings, setSettings] = useState({
                das: 100,
                arr: 30,
                softDropSpeed: 50,
            });

            const [keyBindings, setKeyBindings] = useState({
                moveLeft: 'ArrowLeft',
                moveRight: 'ArrowRight',
                softDrop: 'ArrowDown',
                hardDrop: 'Space',
                rotateClockwise: 'ArrowUp',
                rotateCounterClockwise: 'KeyZ',
                rotate180: 'KeyA',
                hold: 'ShiftLeft',
                pause: 'Escape',
                restart: 'KeyR',
            });

            const gameLoopRef = useRef(null);
            const lastTimeRef = useRef(0);
            const dropCounterRef = useRef(0);
            const lockDelayRef = useRef(null);
            const bagRef = useRef([]);

            const shuffleBag = () => {
                const newBag = [...pieceTypes];
                for (let i = newBag.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newBag[i], newBag[j]] = [newBag[j], newBag[i]];
                }
                bagRef.current = [...bagRef.current, ...newBag];
            };

            const getNextPiece = useCallback(() => {
                if (bagRef.current.length < 7) {
                    shuffleBag();
                }
                return bagRef.current.shift();
            }, []);

            const resetPlayer = useCallback(() => {
                const pieceType = getNextPiece();
                const piece = PIECES[pieceType];
                const newPlayer = {
                    pos: { x: Math.floor(COLS / 2 - piece.shape[0].length / 2), y: 0 },
                    matrix: piece.shape,
                    type: pieceType,
                    rotation: 0,
                };

                if (collide(newPlayer, board)) {
                    setIsGameOver(true);
                    setIsRunning(false);
                } else {
                    setPlayer(newPlayer);
                }

                setNextQueue(bagRef.current.slice(0, 5));
            }, [board, getNextPiece]);

            const startGame = () => {
                setBoard(createEmptyBoard());
                setScore(0);
                setLines(0);
                setLevel(1);
                setIsGameOver(false);
                setIsRunning(true);
                setHoldPiece(null);
                setCanHold(true);
                bagRef.current = [];
                shuffleBag();
                resetPlayer();
                lastTimeRef.current = 0;
                dropCounterRef.current = 0;
                gameLoopRef.current = requestAnimationFrame(gameLoop);
            };

            const pauseGame = () => {
                if (isGameOver) return;
                if (isRunning) {
                    cancelAnimationFrame(gameLoopRef.current);
                } else {
                    lastTimeRef.current = performance.now();
                    gameLoopRef.current = requestAnimationFrame(gameLoop);
                }
                setIsRunning(!isRunning);
            };

            const playerDrop = useCallback((isSoftDrop = false) => {
                if (!player || !isRunning) return;
                
                const newPlayer = { ...player, pos: { ...player.pos, y: player.pos.y + 1 } };

                if (collide(newPlayer, board)) {
                    if (lockDelayRef.current === null) {
                        lockDelayRef.current = setTimeout(() => {
                            merge(player);
                            resetPlayer();
                            setCanHold(true);
                            lockDelayRef.current = null;
                        }, 500);
                    }
                } else {
                    if (lockDelayRef.current) {
                        clearTimeout(lockDelayRef.current);
                        lockDelayRef.current = null;
                    }
                    setPlayer(newPlayer);
                    if (isSoftDrop) {
                        setScore(s => s + 1);
                    }
                }
                dropCounterRef.current = 0;
            }, [player, board, resetPlayer, isRunning]);

            const hardDrop = () => {
                if (!player || !isRunning) return;
                let newPlayer = { ...player };
                let dropCount = 0;
                while (!collide(newPlayer, board)) {
                    newPlayer.pos.y++;
                    dropCount++;
                }
                newPlayer.pos.y--;
                setScore(s => s + dropCount * 2);
                merge(newPlayer);
                resetPlayer();
                setCanHold(true);
            };

            const playerMove = (dir) => {
                if (!player || !isRunning) return;
                const newPlayer = { ...player, pos: { ...player.pos, x: player.pos.x + dir } };
                if (!collide(newPlayer, board)) {
                    setPlayer(newPlayer);
                }
            };

            const rotateMatrix = (matrix, dir) => {
                const newMatrix = matrix.map((_, index) => matrix.map(col => col[index]));
                if (dir > 0) {
                    return newMatrix.map(row => row.reverse());
                }
                return newMatrix.reverse();
            };

            const playerRotate = (dir) => {
                if (!player || !isRunning) return;
                
                const newPlayer = JSON.parse(JSON.stringify(player));
                newPlayer.matrix = rotateMatrix(newPlayer.matrix, dir);
                
                const oldRotation = newPlayer.rotation;
                newPlayer.rotation = (newPlayer.rotation + dir + 4) % 4;

                const kickTable = PIECES[newPlayer.type].shape.length === 4 ? KICK_DATA.I : KICK_DATA.other;
                const kickSet = kickTable[oldRotation];

                for (const kick of kickSet) {
                    const [x, y] = kick;
                    newPlayer.pos.x += x;
                    newPlayer.pos.y -= y; // SRS y-axis is inverted
                    if (!collide(newPlayer, board)) {
                        setPlayer(newPlayer);
                        return;
                    }
                    newPlayer.pos.x -= x;
                    newPlayer.pos.y += y;
                }
            };

            const hold = () => {
                if (!canHold || !isRunning) return;
                const currentPieceType = player.type;
                if (holdPiece) {
                    const newPlayerPiece = PIECES[holdPiece];
                    const newPlayer = {
                        pos: { x: Math.floor(COLS / 2 - newPlayerPiece.shape[0].length / 2), y: 0 },
                        matrix: newPlayerPiece.shape,
                        type: holdPiece,
                        rotation: 0,
                    };
                    setPlayer(newPlayer);
                    setHoldPiece(currentPieceType);
                } else {
                    setHoldPiece(currentPieceType);
                    resetPlayer();
                }
                setCanHold(false);
            };

            const collide = (player, board) => {
                for (let y = 0; y < player.matrix.length; y++) {
                    for (let x = 0; x < player.matrix[y].length; x++) {
                        if (
                            player.matrix[y][x] !== 0 &&
                            (board[y + player.pos.y] && board[y + player.pos.y][x + player.pos.x]) !== 0
                        ) {
                            return true;
                        }
                    }
                }
                return false;
            };

            const merge = (player) => {
                const newBoard = board.map(row => [...row]);
                player.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            newBoard[y + player.pos.y][x + player.pos.x] = value;
                        }
                    });
                });
                sweepRows(newBoard);
            };

            const sweepRows = (newBoard) => {
                let clearedLines = 0;
                outer: for (let y = newBoard.length - 1; y >= 0; --y) {
                    for (let x = 0; x < newBoard[y].length; ++x) {
                        if (newBoard[y][x] === 0) {
                            continue outer;
                        }
                    }
                    const row = newBoard.splice(y, 1)[0].fill(0);
                    newBoard.unshift(row);
                    clearedLines++;
                    y++;
                }

                if (clearedLines > 0) {
                    const newLines = lines + clearedLines;
                    const points = [0, 100, 300, 500, 800][clearedLines] * level;
                    const newLevel = Math.floor(newLines / 10) + 1;
                    setLines(newLines);
                    setScore(s => s + points);
                    setLevel(newLevel);
                }
                setBoard(newBoard);
            };

            const gameLoop = (time) => {
                if (!isRunning) return;

                const deltaTime = time - lastTimeRef.current;
                lastTimeRef.current = time;
                dropCounterRef.current += deltaTime;

                const dropInterval = 1000 / level;
                if (dropCounterRef.current > dropInterval) {
                    playerDrop();
                }

                gameLoopRef.current = requestAnimationFrame(gameLoop);
            };

            const moveState = useRef({ left: false, right: false, down: false, timer: null, repeatTimer: null });

            const handleKeyUp = useCallback((e) => {
                const { moveLeft, moveRight, softDrop } = keyBindings;
                if (e.code === moveLeft) moveState.current.left = false;
                if (e.code === moveRight) moveState.current.right = false;
                if (e.code === softDrop) moveState.current.down = false;

                if (!moveState.current.left && !moveState.current.right && !moveState.current.down) {
                    clearTimeout(moveState.current.timer);
                    clearInterval(moveState.current.repeatTimer);
                    moveState.current.timer = null;
                    moveState.current.repeatTimer = null;
                }
            }, [keyBindings]);

            const handleKeyDown = useCallback((e) => {
                e.preventDefault();
                if (!isRunning) {
                    if (e.code === keyBindings.restart) startGame();
                    return;
                }

                const { moveLeft, moveRight, softDrop, hardDrop, rotateClockwise, rotateCounterClockwise, rotate180, hold: holdKey, pause } = keyBindings;

                if (e.code === moveLeft || e.code === moveRight || e.code === softDrop) {
                    if (moveState.current.timer) return;

                    const move = () => {
                        if (moveState.current.left) playerMove(-1);
                        if (moveState.current.right) playerMove(1);
                        if (moveState.current.down) playerDrop(true);
                    };
                    
                    if (e.code === moveLeft) moveState.current.left = true;
                    if (e.code === moveRight) moveState.current.right = true;
                    if (e.code === softDrop) moveState.current.down = true;

                    move();

                    moveState.current.timer = setTimeout(() => {
                        moveState.current.repeatTimer = setInterval(move, settings.arr);
                    }, settings.das);
                }

                switch (e.code) {
                    case hardDrop: hardDrop(); break;
                    case rotateClockwise: playerRotate(1); break;
                    case rotateCounterClockwise: playerRotate(-1); break;
                    case rotate180: playerRotate(1); playerRotate(1); break;
                    case holdKey: hold(); break;
                    case pause: pauseGame(); break;
                }
            }, [isRunning, keyBindings, settings, playerMove, playerDrop, hardDrop, playerRotate, hold, pauseGame, startGame]);

            useEffect(() => {
                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                };
            }, [handleKeyDown, handleKeyUp]);

            return {
                gameState: { board, player, score, lines, level, isRunning, isGameOver, nextQueue, holdPiece },
                startGame,
                pauseGame,
                restartGame: startGame,
                settings,
                setSettings,
                keyBindings,
                setKeyBindings,
            };
        };

        // --- Constants ---
        const ROWS = 20;
        const COLS = 10;
        const PIECES = {
            'I': { shape: [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], color: '#00FFFF' },
            'J': { shape: [[2,0,0], [2,2,2], [0,0,0]], color: '#0000FF' },
            'L': { shape: [[0,0,3], [3,3,3], [0,0,0]], color: '#FF7F00' },
            'O': { shape: [[4,4], [4,4]], color: '#FFFF00' },
            'S': { shape: [[0,5,5], [5,5,0], [0,0,0]], color: '#00FF00' },
            'T': { shape: [[0,6,0], [6,6,6], [0,0,0]], color: '#800080' },
            'Z': { shape: [[7,7,0], [0,7,7], [0,0,0]], color: '#FF0000' },
        };
        const pieceTypes = Object.keys(PIECES);
        const createEmptyBoard = () => Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        const KICK_DATA = {
            'I': [
                [[0,0], [-2,0], [ 1,0], [-2,-1], [ 1, 2]],
                [[0,0], [-1,0], [ 2,0], [-1, 2], [ 2,-1]],
                [[0,0], [ 2,0], [-1,0], [ 2, 1], [-1,-2]],
                [[0,0], [ 1,0], [-2,0], [ 1,-2], [-2, 1]],
            ],
            'other': [
                [[0,0], [-1,0], [-1, 1], [0,-2], [-1,-2]],
                [[0,0], [ 1,0], [ 1,-1], [0, 2], [ 1, 2]],
                [[0,0], [ 1,0], [ 1, 1], [0,-2], [ 1,-2]],
                [[0,0], [-1,0], [-1,-1], [0, 2], [-1, 2]],
            ]
        };

        // --- GameBoard.tsx ---
        function GameBoard({ gameState }) {
            const { board, player } = gameState;
            const cellSize = 30;

            const renderCells = () => {
                const cells = [];
                const boardRows = board.length;
                const boardCols = board[0].length;

                for (let y = 0; y < boardRows; y++) {
                    for (let x = 0; x < boardCols; x++) {
                        const cellValue = board[y][x];
                        const color = cellValue ? PIECES[pieceTypes[cellValue - 1]].color : '#222';
                        cells.push(
                            <div
                                key={`cell-${y}-${x}`}
                                style={{
                                    width: cellSize,
                                    height: cellSize,
                                    backgroundColor: color,
                                    border: '1px solid #333',
                                    boxSizing: 'border-box',
                                    position: 'absolute',
                                    left: x * cellSize,
                                    top: y * cellSize,
                                }}
                            />
                        );
                    }
                }

                if (player) {
                    const { matrix, pos, type } = player;
                    const color = PIECES[type].color;

                    for (let y = 0; y < matrix.length; y++) {
                        for (let x = 0; x < matrix[y].length; x++) {
                            if (matrix[y][x]) {
                                cells.push(
                                    <div
                                        key={`player-${y}-${x}`}
                                        style={{
                                            width: cellSize,
                                            height: cellSize,
                                            backgroundColor: color,
                                            border: '1px solid #000',
                                            boxSizing: 'border-box',
                                            position: 'absolute',
                                            left: (pos.x + x) * cellSize,
                                            top: (pos.y + y) * cellSize,
                                        }}
                                    />
                                );
                            }
                        }
                    }
                }

                return cells;
            };

            return (
                <div
                    style={{
                        position: 'relative',
                        width: board[0].length * cellSize,
                        height: board.length * cellSize,
                        border: '2px solid #888',
                        backgroundColor: '#111',
                    }}
                >
                    {renderCells()}
                </div>
            );
        }

        // --- PiecePreview.tsx ---
        function PiecePreview({ piece, size = 80 }) {
            if (!piece) {
                return (
                    <div
                        style={{
                            width: size,
                            height: size,
                            border: '1px solid #444',
                            backgroundColor: '#222',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            color: '#888',
                            fontSize: '12px',
                        }}
                    >
                        Empty
                    </div>
                );
            }

            const { shape, color } = PIECES[piece];
            const blockSize = Math.floor(size / 4);
            const matrixSize = shape.length;
            const offsetX = (size - matrixSize * blockSize) / 2;
            const offsetY = (size - matrixSize * blockSize) / 2;

            return (
                <div
                    style={{
                        position: 'relative',
                        width: size,
                        height: size,
                        border: '1px solid #444',
                        backgroundColor: '#222',
                    }}
                >
                    {shape.map((row, y) =>
                        row.map((cell, x) => {
                            if (cell === 0) return null;
                            return (
                                <div
                                    key={`${x}-${y}`}
                                    style={{
                                        position: 'absolute',
                                        left: offsetX + x * blockSize,
                                        top: offsetY + y * blockSize,
                                        width: blockSize,
                                        height: blockSize,
                                        backgroundColor: color,
                                        border: '1px solid #000',
                                    }}
                                />
                            );
                        })
                    )}
                </div>
            );
        }

        // --- GameStats.tsx ---
        function GameStats({ gameState }) {
            const { score, lines, level } = gameState;

            return (
                <div className="space-y-4">
                    <div className="text-center">
                        <div className="text-xs text-gray-400 uppercase tracking-wider mb-1">Score</div>
                        <div className="text-2xl font-bold text-white">{score.toLocaleString()}</div>
                    </div>
                    <div className="text-center">
                        <div className="text-xs text-gray-400 uppercase tracking-wider mb-1">Lines</div>
                        <div className="text-xl font-bold text-green-400">{lines}</div>
                    </div>
                    <div className="text-center">
                        <div className="text-xs text-gray-400 uppercase tracking-wider mb-1">Level</div>
                        <div className="text-xl font-bold text-yellow-400">{level}</div>
                    </div>
                </div>
            );
        }

        // --- GameControls.tsx ---
        function GameControls({ isRunning, isPaused, isGameOver, onStart, onPause, onRestart, onSettings }) {
          return (
            <div className="flex gap-3 justify-center">
              {!isRunning || isGameOver ? (
                <button onClick={isGameOver ? onRestart : onStart} className="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700">
                  {isGameOver ? 'Restart' : 'Start'}
                </button>
              ) : (
                <button onClick={onPause} className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700">
                  {isPaused ? 'Resume' : 'Pause'}
                </button>
              )}
              <button onClick={onRestart} className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700">Restart</button>
              <button onClick={onSettings} className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700">Settings</button>
            </div>
          );
        }

        // --- SettingsDialog.tsx ---
        function SettingsDialog({ open, onOpenChange, settings, onSettingsChange, keyBindings, onKeyBindingsChange }) {
            const [localSettings, setLocalSettings] = useState(settings);
            const [localKeyBindings, setLocalKeyBindings] = useState(keyBindings);
            const [isBinding, setIsBinding] = useState(null);

            useEffect(() => { setLocalSettings(settings); }, [settings]);
            useEffect(() => { setLocalKeyBindings(keyBindings); }, [keyBindings]);

            const handleSettingChange = (key, value) => {
                setLocalSettings(prev => ({ ...prev, [key]: Number(value) }));
            };

            const handleKeyBind = (action) => {
                setIsBinding(action);
            };

            useEffect(() => {
                if (isBinding) {
                    const handleKeyPress = (e) => {
                        setLocalKeyBindings(prev => ({ ...prev, [isBinding]: e.code }));
                        setIsBinding(null);
                    };
                    window.addEventListener('keydown', handleKeyPress);
                    return () => window.removeEventListener('keydown', handleKeyPress);
                }
            }, [isBinding]);

            const handleSave = () => {
                onSettingsChange(localSettings);
                onKeyBindingsChange(localKeyBindings);
                onOpenChange(false);
            };

            if (!open) return null;

            return (
                <div className="fixed inset-0 bg-black/50 flex items-center justify-center">
                    <div className="bg-gray-800 border border-gray-700 rounded-xl p-8 max-w-lg w-full">
                        <h2 className="text-2xl font-bold mb-6">Settings</h2>
                        <div className="space-y-6">
                            <div>
                                <h3 className="text-lg font-semibold mb-2">Gameplay</h3>
                                <div className="grid grid-cols-2 gap-4">
                                    <label className="flex flex-col">
                                        <span className="text-sm text-gray-400">DAS (ms)</span>
                                        <input type="number" value={localSettings.das} onChange={(e) => handleSettingChange('das', e.target.value)} className="bg-gray-900 border border-gray-600 rounded p-2 mt-1" />
                                    </label>
                                    <label className="flex flex-col">
                                        <span className="text-sm text-gray-400">ARR (ms)</span>
                                        <input type="number" value={localSettings.arr} onChange={(e) => handleSettingChange('arr', e.target.value)} className="bg-gray-900 border border-gray-600 rounded p-2 mt-1" />
                                    </label>
                                </div>
                            </div>
                            <div>
                                <h3 className="text-lg font-semibold mb-2">Key Bindings</h3>
                                <div className="grid grid-cols-2 gap-x-8 gap-y-4">
                                    {Object.entries(localKeyBindings).map(([action, key]) => (
                                        <div key={action} className="flex items-center justify-between">
                                            <span className="capitalize">{action.replace(/([A-Z])/g, ' $1')}</span>
                                            <button onClick={() => handleKeyBind(action)} className="bg-gray-700 hover:bg-gray-600 rounded px-3 py-1">
                                                {isBinding === action ? 'Press a key...' : key}
                                            </button>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                        <div className="flex justify-end gap-4 mt-8">
                            <button onClick={() => onOpenChange(false)} className="px-4 py-2 bg-gray-600 rounded hover:bg-gray-700">Cancel</button>
                            <button onClick={handleSave} className="px-4 py-2 bg-purple-600 rounded hover:bg-purple-700">Save</button>
                        </div>
                    </div>
                </div>
            );
        }

        // --- TetrisGame.tsx ---
        function TetrisGame() {
          const { gameState, startGame, pauseGame, restartGame, settings, setSettings, keyBindings, setKeyBindings } = useTetris();
          const [showSettings, setShowSettings] = useState(false);

          return (
            <div className="min-h-screen text-white flex items-center justify-center p-4 font-mono">
              <div className="w-full max-w-6xl">
                <div className="text-center mb-8">
                  <h1 className="text-5xl font-bold text-purple-400">TETRIS</h1>
                  <p className="text-sm text-gray-400 mt-2">Modern Tetris with SRS</p>
                </div>
                <div className="flex flex-col lg:flex-row gap-8 items-start justify-center">
                  <div className="bg-gray-800 border border-gray-700 rounded-xl p-6 min-w-[200px] space-y-6">
                    <div>
                      <h3 className="text-xs font-semibold text-purple-400 uppercase tracking-wider mb-3">Hold</h3>
                      <PiecePreview piece={gameState.holdPiece} />
                    </div>
                    <GameStats gameState={gameState} />
                  </div>
                  <div className="flex flex-col items-center space-y-6">
                    <GameControls
                      isRunning={gameState.isRunning}
                      isPaused={!gameState.isRunning && gameState.player !== null}
                      isGameOver={gameState.isGameOver}
                      onStart={startGame}
                      onPause={pauseGame}
                      onRestart={restartGame}
                      onSettings={() => setShowSettings(true)}
                    />
                    <div className="relative">
                      <GameBoard gameState={gameState} />
                      {gameState.isGameOver && (
                        <div className="absolute inset-0 bg-black/50 flex items-center justify-center text-3xl font-bold">
                          GAME OVER
                        </div>
                      )}
                    </div>
                  </div>
                  <div className="bg-gray-800 border border-gray-700 rounded-xl p-6 min-w-[200px] space-y-4">
                    <h3 className="text-xs font-semibold text-purple-400 uppercase tracking-wider mb-3">Next</h3>
                    {gameState.nextQueue.map((piece, index) => (
                      <PiecePreview key={index} piece={piece} />
                    ))}
                  </div>
                </div>
                <SettingsDialog
                  open={showSettings}
                  onOpenChange={setShowSettings}
                  settings={settings}
                  onSettingsChange={setSettings}
                  keyBindings={keyBindings}
                  onKeyBindingsChange={setKeyBindings}
                />
              </div>
            </div>
          );
        }

        const domContainer = document.querySelector('#root');
        const root = ReactDOM.createRoot(domContainer);
        root.render(<TetrisGame />);
    </script>
</body>
</html>
